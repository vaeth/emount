#!/usr/bin/env perl
require 5.012;
package Emount v2.8.4;

use strict;
use integer;
use Getopt::Long 2.24 ();
use Cwd ();
use File::Spec ();
# use Pod::Usage ();

=head1 NAME

emount/eumount - (u)mount devices using cryptsetup

=head1 SYNOPSIS

B<e(u)mount> [options] devicelist

To get an extended help, use option B<--man> or B<-?>

=head1 DESCRIPTION

This script (u)mounts encrypted devices according to S<F</etc/fstab>>.

The devices are created or removed with F<cryptsetup> if necessary.

You can use your own script instead with the option --cryptsetup.
You may want to use this e.g. to pass a cypher or hash to F<cryptsetup>
or to pipe a password.

=over 8

=item For example, your script may look like

#!/bin/sh
gpg --quiet --decrypt FILE.gpg E<verbar> \
   cryptsetup -h sha512 -c twofish-cbc-essiv:sha256 -s 256 "$@"

=item For each encrypted device the file F</etc/fstab> should
contain a line like

/dev/mapper/e-I<DEVICE> I<DIR> I<OPTIONS> 0 0

=item where

I<OPTIONS> should contain B<noauto> to avoid mounting at boot time

=item and

I<DEVICE> is the name of the device containing the encrypted data
(e.g. C<hda> or C<sda> or C<loop6>).
The symbol C<.> in I<DEVICE> has the special meaning of C</>.

For instance, C</dev/mapper/e-mapper.x> as entry in F</etc/fstab>
means that the device with the encrypted data is F</dev/mapper/x>.

=back

=head1 OPTIONS AND ARGUMENTS

=over 8

=item B<--help> or B<-h>

Display brief help.

=item B<--man> or B<-?>

Display extended help as a manpage.

=item B<--cryptsetup=>I<name> or B<-c> I<name>

Use I<name> instead of F<cryptsetup>

=item B<--opt=>I<string> or B<-o> I<string>

Pass I<string> as an option to F<cryptsetup> for "create".
You can use this e.g. in your own F<cryptsetup> replacement to get the
passphrase from a different gpg file.
This option can be used accumulatively.

=item B<--mount> or B<-m>

Always mount, regardless of the name under which the script is called

=item B<--umount>  B<--unmount> or B<-u>

Always umount, regardless of the name under which the script is called

=item B<--version> or B<-v>

print version number

=item B<-->

Last option

=back

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Static variables:

our $VERSION;
my $umountmode = ($0 =~ m{un?mount[\w\.\,]*$}i);
my $name = ($umountmode ? 'eumount' : 'emount');
my $devnull = File::Spec->devnull();

# Global variables:

my %dev = ();
my $exitstate = 0;
my $luks = '';
my $remove = 'remove';

# Default options:

my $cryptsetup = 'cryptsetup';
my @passopt = ();

# Functions:

sub addtodev {
	my ($a, $b) = @_;
	$dev{$a} = $b unless(exists $dev{$a})
}

sub check_luks {
	my ($d) = @_;
	return '' unless(&myexec($cryptsetup, 'isLuks', $d));
	$remove = 'luksClose';
	$luks = 1
}

# Print and execute command.
# As a side effect, set $exitstate if execution was not successful.

sub myexec {
	print(join(' ', @_), "\n");
	my $s = system(@_);
	if(($s < 0) && ($s & 127)) {
		$s = 127
	} else {
		$s >>= 8
	}
	return 1 unless($s);
	$exitstate = $s if($exitstate < $s);
	''
}

sub error() {
	print(STDERR "$name: error: ",
		join("\n" . (' ' x (length($name) + 9)), @_), "\n")
}

sub warning() {
	print(STDERR "$name: warning: ",
		join("\n" . (' ' x (length($name) + 11)), @_), "\n")
}

sub version {
	print($name, ' ', $VERSION, "\n");
	exit(0)
}

sub pod2usage {
	require Pod::Usage;;
	&Pod::Usage::pod2usage
}

# Parse options:

Getopt::Long::Configure(qw(gnu_getopt));
Getopt::Long::GetOptions(
	'help|h', sub { &pod2usage(0) },
	'man|?', sub { &pod2usage(-verbose => 2, -exit => 0) },
	'cryptsetup|c=s', \$cryptsetup,
	'opt|o=s', \@passopt,
	'mount|m',  sub { $umountmode = '' },
	'umount|unmount|u', \$umountmode,
	'version|V', \&version
) or &pod2usage(2);

&pod2usage(2) unless(@ARGV);

# Parse /etc/fstab

{
	local @ARGV = ('/etc/fstab'); # Fake next while:
	while(<>) {
		if(m{^\s*/dev/mapper/e\-([^\s]+)\s+([^\s]+)}) {
			my $dev = $1;
			&addtodev($2, $dev);
			&addtodev($dev, $dev);
			&addtodev("/dev/mapper/e-$dev", $dev);
			&addtodev("/dev/mapper/$dev", $dev);
			my $cut = $dev;
			$cut =~ s{\.}{/};
			&addtodev($cut, $dev);
			&addtodev("/dev/$cut", $dev);
			&addtodev("/dev/mapper/$cut", $dev);
			&addtodev("/dev/mapper/dev/$cut", $dev);
		}
	}
}

# Main loop:

for my $nameref (@ARGV) {
	my $a = Cwd::abs_path($nameref);
	unless(exists($dev{$a})) {
		&error("no entry in /etc/fstab for $a");
		$exitstate = 2;
		next
	}
	my $d = $dev{$a};
	my $c = "e-$d";
	my $m = "/dev/mapper/$c";
	$d =~ s{\.}{/}g;
	$d = "/dev/$d";
	if($umountmode) {
		if(-e $m) {
			if(&myexec('umount', $m)) {
				&check_luks($d);
				&error("could not remove $c")
					unless(&myexec($cryptsetup, @passopt, $remove, $c));
				# Close repeatedly if necessary to deal with slave mounts;
				while() {
					sleep(1);
					# redirect stderr to /dev/null to suppress error messages
					my $olderr = undef;
					$olderr = undef unless(open($olderr, '>&', \*STDERR)
						&& open(STDERR, '>', File::Spec->devnull()));
					my $repeat = ((system('umount', $a) == 0) ||
						(system('umount', $m) == 0));
					open(STDERR, '>&', $olderr) if(defined($olderr));
					last unless($repeat)
				}
			} else {
				&error("could not umount $m")
			}
		} else {
			&warning("$m does not exist")
		}
	} elsif(-e $m) {
		&warning("$m already exists")
	} else {
		my $stat;
		if(&check_luks($d)) {
			$stat = &myexec($cryptsetup, @passopt, 'luksOpen', $d, $c)
		} else {
			$stat = &myexec($cryptsetup, @passopt, 'create', $c, $d)
		}
		if(!$stat) {
			&error("could not create $c")
		} else {
			unless(&myexec('mount', $m)) {
				&error("could not mount $m",
					'perhaps the password was misspelled;',
					"removing $c again");
				for(my $i = 0 ; ; ++$i) {
					last if(&myexec($cryptsetup, $remove, $c));
					if($i < 5) {
						&warning("removing $c failed",
							'retrying in a second');
						sleep(1)
					} else {
						&error("could not remove $c");
						last
					}
				}
			}
		}
	}
}
exit($exitstate);
